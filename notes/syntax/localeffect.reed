
type 
type Fallible[T: Boxed, E: Boxed] = { kind: Success, value: T } | { kind: Error, error: E };

<TODO: kw> Fallible[T, E] {
    handler error(E);

    // this would always be inlined, so that the handler jump could be local
    func unwrap(Fallible[T] f): T {
        match f {
            { kind: Success, value } => return T;
            { kind: Error, error } => error(E)
        }
    }
}

func main() {
    Fallible {
        let res1: T = fallible1();
        let res2: T = fallible2();

    } using error(error: E) {
        if (<error is non-fatal>) {
            continue <error value>;
        }
    }
}