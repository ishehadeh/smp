
type 
type Fallible[T: Boxed, E: Boxed] = { kind: Success, value: T } | { kind: Error, error: E };

<TODO: kw> Fallible {
    handler error[E](error: E);

    func wrap[T, E](value: T): Fallible[T, E] {
        return { kind: Success, value }
    }

    // this would always be inlined, so that the handler jump could be local
    func unwrap[T, E](Fallible[T, E] f): T {
        match f {
            { kind: Success, value } => return T;
            { kind: Error, error } => error(E)
        }
    }
}

func main() {
    Fallible {
        let res1: T = fallible1();
        let res2: T = fallible2();

    } using error(error: MyNonFatalError) {
        continue <error value>;
    } using error(error: MyFatalError) {
        print("oh no!");
        exit(1);
    }
}

