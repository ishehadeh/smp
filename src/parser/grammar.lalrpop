use std::str::FromStr;
use crate::parser::{ParseError, Ast, Param, AnonType, StructMember, InfixOp};
use lalrpop_util::ErrorRecovery;
use crate::parser::lexer::{
  Token,
  Lexer,
};

grammar<'input, 'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, ParseError>>);

extern {
    // Set the error type for the parse result.
    // NOTE: this is only for fatal errors,
    //       recovered errors are passed back through a parameter to the grammar. 
    type Error = ParseError;
    type Location = usize;

    enum Token<'input> {
        "let" => Token::KeywordLet,
        "func" => Token::KeywordFunc,
        "to" => Token::KeywordTo,
        "int" => Token::KeywordInt,
        "mut" => Token::KeywordMut,
        "type" => Token::KeywordType,
        "if" => Token::KeywordIf,
        "else" => Token::KeywordElse,
 
        "ident" => Token::Identifier(<&'input str>),
        "literal-int" => Token::LiteralInteger(<&'input str>),

        "(" => Token::ParenLeft,
        ")" => Token::ParenRight,
        "{" => Token::BraceCurlyLeft,
        "}" => Token::BraceCurlyRight,
        ";" => Token::Semicolon,
        ":" => Token::Colon,
        "," => Token::Comma,
        "+" => Token::OperatorAdd,
        "-" => Token::OperatorSub,
        "*" => Token::OperatorMul,
        "/" => Token::OperatorDiv,
        "=" => Token::OperatorAssign,
        "==" => Token::OperatorCmpEqual,
        "!=" => Token::OperatorCmpNotEqual,

        // " " => Token::Whitespace(<&'input str>),
    }
}

pub TypeReference: AnonType = {
    <name: "ident"> => AnonType::TypeReference {
        name: name.to_string(),
        parameters: (),
    }
};

/// One ore more items that are separated by a comma.
/// Source: https://github.com/RustPython/Parser/blob/9ce55aefdeb35e2f706ce0b02d5a2dfe6295fc57/parser/src/python.lalrpop#L1659
OneOrMore<T>: Vec<T> = {
    <e:T> => vec![e],
    <mut v: OneOrMore<T>> "," <e:T> => {
        v.push(e);
        v
    }
};


pub Param: Param = {
    <name:"ident"> ":" <typ:AnonType> => Param {
        name: name.to_string(),
        typ,
    }
};

pub DefParams: Vec<Param> = {
    "(" ")" => vec![],
    "(" <params: OneOrMore<Param>> ")" => params
};

pub DefFunction: Ast = {
    "func" <name:"ident"> <params:DefParams> ":" <typ:AnonType> <block: Block> => {
        Ast::DefFunction {
            name: name.to_string(),
            params,
            return_type: typ,
            body: Box::new(block)
        }
    }
};

pub DefStructMember: StructMember = {
    "mut" <name:"ident"> ":" <typ:AnonType> => {
        StructMember {
            name: name.to_string(),
            typ,
            mutable: true,
        }
    },

    <name:"ident"> ":" <typ:AnonType> => {
        StructMember {
            name: name.to_string(),
            typ,
            mutable: false,
        }
    },
}

pub TypeIntegerRange: AnonType = {
    "int" <lo:"literal-int"> "to" <hi:"literal-int"> => AnonType::IntegerRange {
        inclusive_low: lo.to_string(),
        inclusive_high: hi.to_string(),
    },
}

pub StructBody: AnonType = {
    "{" "}" => AnonType::StructBody { members: vec![] },
    "{" <members: OneOrMore<DefStructMember>> "}" => {
        AnonType::StructBody {
            members
        }
    }
}

pub AnonType: AnonType = {
    StructBody,
    TypeIntegerRange,
    TypeReference,
}

pub DefType: Ast = {
    "type" <name:"ident"> "=" <typ:AnonType> ";" => {
        Ast::DefType {
            name: name.to_string(),
            typ,
        }
    }
}

pub StmtIf: Ast = {
    "if" <condition:Expr> <body:Block> => Ast::StmtIf {
        condition: Box::new(condition),
        body: Box::new(body),
        else_: None,
    },

    "if" <condition:Expr> <body:Block> "else" <else_:Block> => Ast::StmtIf {
        condition: Box::new(condition),
        body: Box::new(body),
        else_: Some(Box::new(else_)),
    }
}

pub ExprCall: Ast = {
    <fname:"ident"> "(" ")" => Ast::ExprCall {
        function_name: fname.to_string(),
        paramaters: vec![]
    },

    <fname:"ident"> "(" <paramaters:OneOrMore<Expr>> ")" => Ast::ExprCall {
        function_name: fname.to_string(),
        paramaters,
    }
}

pub Expr: Ast = {
    <lhs:AtomicExpr> <op:InfixOp> <rhs:ErrNoExplicitExprGrouping> => Ast::Expr {
        lhs: Box::new(lhs), op, rhs: Box::new(rhs) 
    },
    AtomicExpr
};


pub StmtLet: Ast = {
    "let" <name:"ident"> ":" <typ:AnonType> "=" <value:Expr> => Ast::StmtLet {
        name: name.to_string(),
        value_type: typ,
        value: Box::new(value),
    }
}

pub Stmt: Ast = {
    StmtLet,
    StmtIf,
    Expr,
}

pub StmtList: Vec<Ast> = {
    <e:Stmt> => vec![e],
    <mut v: StmtList> ";" <e:Stmt> => {
        v.push(e);
        v
    }
}

pub Block: Ast = {
    "{" "}" => Ast::Block { returns: false, statements: vec![]  },
    "{" <statements: StmtList> "}" => Ast::Block { returns: true, statements },
    "{" <statements: StmtList> ";" "}" => Ast::Block { returns: false, statements },
}

pub ErrNoExplicitExprGrouping: Ast = {
    // TODO: detailed error message
    <lhs:AtomicExpr> <op:InfixOp> <rhs:Expr> => {
        Ast::Repaired(Box::new(Ast::Expr {
            lhs: Box::new(lhs), op, rhs:Box::new(rhs),
        }))
    },
    AtomicExpr,
};

pub AtomicExpr: Ast = {
    <n:Number> => n,
    <i:Ident> => i,
    <c:ExprCall> => c,
    "(" <e:Expr> ")" => e,

    // error recovery handler
    // ref: https://github.com/tweag/nickel/blob/f7ffe31697d639ba7d10bcb757a3a8ba73f011a7/core/src/parser/grammar.lalrpop#L431C21-L431C43
    <l: @L> <e: !> <r: @R> => { errors.push(e.clone()); Ast::Error },
};

pub InfixOp: InfixOp = {
    "+" => InfixOp::Add,
    "-" => InfixOp::Sub,
    "*" => InfixOp::Mul,
    "/" => InfixOp::Div,
    "!=" => InfixOp::CmpNotEqual,
    "==" => InfixOp::CmpEqual,
}

pub Number: Ast = <s:"literal-int"> => Ast::Number(s.parse::<u32>().unwrap());
pub Ident: Ast = <s:"ident"> => Ast::Ident(s.to_string());

TopLevel: Ast = { DefFunction, DefType };
TopLevelList: Vec<Ast> = {
    <e:TopLevel> => vec![e],
    <mut v: TopLevelList> <e:TopLevel> => {
        v.push(e);
        v
    }
}


pub Program: Ast = {
    <definitions:TopLevelList> => {
        Ast::Program {
            definitions
        }
    }
};
