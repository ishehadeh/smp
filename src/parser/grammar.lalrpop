use std::str::FromStr;
use crate::parser::{ParseError, Ast, Param, AnonType, StructMember, InfixOp};
use lalrpop_util::ErrorRecovery;


grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, ParseError>>);

extern {
    // Set the error type for the parse result.
    // NOTE: this is only for fatal errors,
    //       recovered errors are passed back through a parameter to the grammar. 
    type Error = ParseError;
}

pub TypeReference: AnonType = {
    <name: IdentChars> => AnonType::TypeReference {
        name: name.to_string(),
        parameters: (),
    }
};

/// One ore more items that are separated by a comma.
/// Source: https://github.com/RustPython/Parser/blob/9ce55aefdeb35e2f706ce0b02d5a2dfe6295fc57/parser/src/python.lalrpop#L1659
OneOrMore<T>: Vec<T> = {
    <e:T> => vec![e],
    <mut v: OneOrMore<T>> "," <e:T> => {
        v.push(e);
        v
    }
};


pub Param: Param = {
    <name:IdentChars> ":" <typ:AnonType> => Param {
        name: name.to_string(),
        typ,
    }
};

pub DefParams: Vec<Param> = {
    "(" ")" => vec![],
    "(" <params: OneOrMore<Param>> ")" => params
};

pub DefFunction: Ast = {
    "func" <name:IdentChars> <params:DefParams> ":" <typ:AnonType> <block: Block> => {
        Ast::DefFunction {
            name: name.to_string(),
            params,
            return_type: typ,
            body: Box::new(block)
        }
    }
};

pub DefStructMember: StructMember = {
    "mut " <name:IdentChars> ":" <typ:AnonType> => {
        StructMember {
            name: name.to_string(),
            typ,
            mutable: true,
        }
    },

    <name:IdentChars> ":" <typ:AnonType> => {
        StructMember {
            name: name.to_string(),
            typ,
            mutable: false,
        }
    },
}

pub TypeIntegerRange: AnonType = {
    "int" <lo:DecChars> "to" <hi:DecChars> => AnonType::IntegerRange {
        inclusive_low: lo.to_string(),
        inclusive_high: hi.to_string(),
    },
}

pub StructBody: AnonType = {
    "{" "}" => AnonType::StructBody { members: vec![] },
    "{" <members: OneOrMore<DefStructMember>> "}" => {
        AnonType::StructBody {
            members
        }
    }
}

pub AnonType: AnonType = {
    StructBody,
    TypeIntegerRange,
    TypeReference,
}

pub DefType: Ast = {
    "type" <name:IdentChars> "=" <typ:AnonType> ";" => {
        Ast::DefType {
            name: name.to_string(),
            typ,
        }
    }
}

pub Expr: Ast = {
    <lhs:AtomicExpr> <op:InfixOp> <rhs:ErrNoExplicitExprGrouping> => Ast::Expr {
        lhs: Box::new(lhs), op, rhs: Box::new(rhs) 
    },
    ErrBadInfixOp
};


pub StmtLet: Ast = {
    "let " <name:IdentChars> ":" <typ:AnonType> "=" <value:Expr> => Ast::StmtLet {
        name: name.to_string(),
        return_type: typ,
        value: Box::new(value),
    }
}

pub Stmt: Ast = {
    StmtLet,
    Expr
}

pub StmtList: Vec<Ast> = {
    <e:Stmt> => vec![e],
    <mut v: StmtList> ";" <e:Stmt> => {
        v.push(e);
        v
    }
}

pub Block: Ast = {
    "{" "}" => Ast::Block { returns: false, statements: vec![]  },
    "{" <statements: StmtList> "}" => Ast::Block { returns: true, statements },
    "{" <statements: StmtList> ";" "}" => Ast::Block { returns: false, statements },
}

pub ErrNoExplicitExprGrouping: Ast = {
    // TODO: detailed error message
    <lhs:AtomicExpr> <op:InfixOp> <rhs:Expr> => {
        Ast::Repaired(Box::new(Ast::Expr {
            lhs: Box::new(lhs), op, rhs:Box::new(rhs),
        }))
    },
    ErrBadInfixOp,
};

// match things that look like they could be infix ops in between expressions for better error handling
pub ErrBadInfixOp: Ast = {
    <lhs:AtomicExpr> <op: r"[\\~!@#$%^&`]|([\*\+\-/\\]{2})"> <rhs:AtomicExpr> => {
        Ast::Repaired(Box::new(Ast::Expr {
            // TODO proper missing infix op
            lhs: Box::new(lhs), op: InfixOp::Add, rhs:Box::new(rhs),
        }))
    },
    AtomicExpr,
}

pub AtomicExpr: Ast = {
    <n:Number> => n,
    <i:Ident> => i,
    "(" <e:Expr> ")" => e,

    // error recovery handler
    // ref: https://github.com/tweag/nickel/blob/f7ffe31697d639ba7d10bcb757a3a8ba73f011a7/core/src/parser/grammar.lalrpop#L431C21-L431C43
    <l: @L> <e: !> <r: @R> => { errors.push(e.clone()); Ast::Error },
};

pub InfixOp: InfixOp = {
    "+" => InfixOp::Add,
    "-" => InfixOp::Sub,
    "*" => InfixOp::Mul,
    "/" => InfixOp::Div,
}

pub IdentChars = r"[a-zA-Z_][a-zA-Z_0-9]*";
pub DecChars = r"[+-]?[0-9]+";

pub Number: Ast = <s:DecChars> => Ast::Number(i32::from_str(s).unwrap());
pub Ident: Ast = <s:r"[a-zA-Z_][a-zA-Z_0-9]*"> => Ast::Ident(s.to_string());

TopLevel: Ast = { DefFunction, DefType };
TopLevelList: Vec<Ast> = {
    <e:TopLevel> => vec![e],
    <mut v: TopLevelList> <e:TopLevel> => {
        v.push(e);
        v
    }
}


pub Program: Ast = {
    <definitions:TopLevelList> => {
        Ast::Program {
            definitions
        }
    }
};
